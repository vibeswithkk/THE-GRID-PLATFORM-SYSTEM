syntax = "proto3";

package tgp.scheduler.v1;

// Scheduler service for managing distributed workloads
service SchedulerService {
  // Register a worker node in the cluster
  rpc RegisterNode(RegisterNodeRequest) returns (RegisterNodeResponse);
  
  // Send periodic heartbeat and resource updates
  rpc ReportResources(ResourceReport) returns (ResourceAck);
  
  // Submit a job for scheduling
  rpc SubmitJob(JobSubmitRequest) returns (JobSubmitResponse);
  
  // Get job status
  rpc GetJobStatus(JobStatusRequest) returns (JobStatusResponse);
  
  // Get cluster status
  rpc GetClusterStatus(ClusterStatusRequest) returns (ClusterStatusResponse);
  
  // Assign job to worker (Scheduler → Worker)
  rpc AssignJob(JobAssignment) returns (JobAssignmentAck);
  
  // Update job status (Worker → Scheduler)  
  rpc UpdateJobStatus(JobStatusUpdate) returns (JobStatusUpdateAck);
}

// Node registration
message RegisterNodeRequest {
  string node_id = 1;
  string hostname = 2;
  uint32 cpu_cores = 3;
  double total_memory_gb = 4;
  uint32 gpu_count = 5;
  string location = 6;
  double cost_per_hour = 7;
}

message RegisterNodeResponse {
  bool success = 1;
  string message = 2;
  string cluster_id = 3;
}

// Resource reporting (from blueprint: Economic Fabric - resource tracking)
message ResourceReport {
  string node_id = 1;
  uint32 available_cpu = 2;
  double available_memory_gb = 3;
  double available_disk_gb = 4;
  uint32 available_gpu = 5;
  int64 timestamp = 6;
}

message ResourceAck {
  bool received = 1;
}

// Job submission (implements Formula 4.1 optimization)
message JobSubmitRequest {
  string job_id = 1;
  JobType job_type = 2;
  ResourceRequirements resources = 3;
  SlaConstraints sla = 4;
  bytes job_data = 5; // Serialized job configuration
}

enum JobType {
  JOB_TYPE_UNSPECIFIED = 0;
  JOB_TYPE_TRAINING = 1;
  JOB_TYPE_INFERENCE = 2;
  JOB_TYPE_DATA_PROCESSING = 3;
}

message ResourceRequirements {
  uint32 cpu_cores = 1;
  uint32 memory_gb = 2;
  uint32 gpu_count = 3;
  uint32 disk_gb = 4;
}

message SlaConstraints {
  uint64 max_latency_ms = 1;
  optional double max_budget_usd = 2;
  optional int64 deadline = 3;
}

message JobSubmitResponse {
  bool success = 1;
  string job_id = 2;
  string assigned_node = 3;
  CostEstimate cost_estimate = 4;
  string message = 5;
}

message CostEstimate {
  double compute_cost_usd = 1;
  double data_transfer_usd = 2;
  double idle_opportunity_usd = 3;
  double total_cost_usd = 4;
  uint64 estimated_latency_ms = 5;
}

// Job status
message JobStatusRequest {
  string job_id = 1;
}

message JobStatusResponse {
  string job_id = 1;
  JobStatus status = 2;
  string assigned_node = 3;
  CostEstimate final_cost = 4;
}

enum JobStatus {
  JOB_STATUS_UNSPECIFIED = 0;
  JOB_STATUS_PENDING = 1;
  JOB_STATUS_SCHEDULED = 2;
  JOB_STATUS_RUNNING = 3;
  JOB_STATUS_COMPLETED = 4;
  JOB_STATUS_FAILED = 5;
}

// Cluster status
message ClusterStatusRequest {}

message ClusterStatusResponse {
  uint32 total_nodes = 1;
  uint32 active_nodes = 2;
  uint32 total_jobs = 3;
  uint32 running_jobs = 4;
  repeated NodeInfo nodes = 5;
}

message NodeInfo {
  string node_id = 1;
  string hostname = 2;
  uint32 available_cpu = 3;
  double available_memory_gb = 4;
  string location = 5;
  bool is_active = 6;
}

// Job assignment (Scheduler → Worker)
message JobAssignment {
  string job_id = 1;
  string job_type = 2;
  string container_image = 3;
  repeated string command = 4;
  map<string, string> environment = 5;
  uint32 cpu_limit = 6;
  uint64 memory_limit_mb = 7;
}

message JobAssignmentAck {
  bool accepted = 1;
  string message = 2;
}

// Job status update (Worker → Scheduler)
message JobStatusUpdate {
  string job_id = 1;
  JobStatus status = 2;
  int64 exit_code = 3;
  string logs = 4;
  string error_message = 5;
}

message JobStatusUpdateAck {
  bool received = 1;
}
